ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 1   


ARM COMPILER V2.41, COMPILATION OF MODULE final
OBJECT MODULE PLACED IN final.OBJ
COMPILER INVOKED BY: C:\Keil\ARM\BIN\CA.exe final.c THUMB BROWSE DEBUG TABS(4) 

stmt  level    source

    1          #include <stdio.h>
    2          #include "lpc214x.h"
    3          #include <string.h>
    4          #include <stdlib.h>
    5          
    6          // Function Prototypes
    7          void wait_us (unsigned long);
    8          void GPIO_Port_Low(unsigned int);
    9          void GPIO_Port_High(unsigned int);
   10          void GPIO_Set_Port(unsigned int , unsigned int);
   11          void disp_cmd(unsigned char);
   12          void disp_write(unsigned char);
   13          void lcd_init(void);
   14          void Delay(int);
   15          void Delay2(void);
   16          
   17          // Macros
   18          #define DISP_FUNC 0x38 // sets the display to 4-bit, 2 lines, 5x7 chars + cursor-off
   19          #define DISP_ENTRY 0x06
   20          #define DISP_CNTL 0x08
   21          #define DISP_ON 0x04
   22          #define DISP_CURSOR 0x02
   23          #define DISP_CLEAR 0x01
   24          #define DISP_HOME 0x02
   25          #define DISP_POS 0x80
   26          #define DISP_BLINK 0x01
   27          #define DISPDATA_MASK 0x00ff0000  // four(!) bit data bus to the display panel connected to GPIO[12..15]
   28          #define ENABLE_MASK 1<<24 //toggal BIT for testing BY SP
   29          #define REGSEL_MASK 1<<25 //toggal BIT for testing BY SP
   30          #define LONG_DELAY 2000
   31          #define SHORT_DELAY 400
   32          
   33          // Generic Delay Function
   34          void Delay(int delay)
   35          {
   36   1        unsigned int i,j;
   37   1        for(i=0; i<delay; i++)
   38   1        for(j=0; j<1234; j++);
   39   1      }
   40          
   41          void wait_us (unsigned long usdelay )
   42          {
   43   1        static unsigned long i;
   44   1        usdelay=usdelay/0x10;
   45   1        for(i=0;i<=usdelay;i++)
   46   1        {
   47   2          // Nothing
   48   2        }
   49   1      }
   50          void GPIO_Port_Low(unsigned int value)
   51          {
   52   1        IO1CLR = value; // clear zeros'
   53   1        wait_us(1); // slow down timing for LCD compatibility
   54   1      }
   55          void GPIO_Port_High(unsigned int value){
   56   1        IO1SET = value; // set ones'
   57   1        wait_us(1); // slow down timing for LCD compatibility
   58   1      }
   59          void GPIO_Set_Port(unsigned int mask, unsigned int value)
ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 2   

   60          {
   61   1        IO1SET = mask & value; // set ones'
   62   1        IO1CLR = mask & (~value); // clear zeros'
   63   1        wait_us(1); // slow down timing for LCD compatibility
   64   1      }
   65          void disp_cmd(unsigned char cmd)
   66          {
   67   1        IO1DIR = (IO1DIR | DISPDATA_MASK | REGSEL_MASK | ENABLE_MASK); // set ports to outputs
   68   1        GPIO_Set_Port(DISPDATA_MASK, cmd<<16); // latch the command
   69   1        GPIO_Port_Low(REGSEL_MASK); // select the command reg = 0
   70   1        wait_us(1);
   71   1        GPIO_Port_High(ENABLE_MASK); // latch the command into the LCD panel = 1 - first nibble
   72   1        wait_us(1);
   73   1        GPIO_Port_Low(ENABLE_MASK); // ENABLE=0;
   74   1        wait_us(1);
   75   1      }
   76          void disp_write(unsigned char value)
   77          {
   78   1        IO1DIR = IO1DIR | DISPDATA_MASK | REGSEL_MASK | ENABLE_MASK; // select write mode RDWR=0
   79   1        GPIO_Set_Port(DISPDATA_MASK, value<<16); // latch the data upper nibble
   80   1        GPIO_Port_High(REGSEL_MASK); // select the command reg = 1 select data reg
   81   1        wait_us(1);
   82   1        GPIO_Port_High(ENABLE_MASK); // latch the command into the LCD panel = 1
   83   1        wait_us(1);
   84   1        GPIO_Port_Low(ENABLE_MASK); // ENABLE=0;
   85   1        wait_us(1);
   86   1      }
   87          void lcd_init(void) {
   88   1        unsigned char counter;
   89   1        IO1DIR = IO1DIR | DISPDATA_MASK | REGSEL_MASK |ENABLE_MASK;  // select port direction=output
   90   1        wait_us(20000); // wait for LCD to reset itself
   91   1        for(counter = 0; counter <3; counter++){
   92   2          GPIO_Set_Port(DISPDATA_MASK, (0x00020000)); // latch the command 0x30
   93   2          GPIO_Port_Low(REGSEL_MASK); // select the command reg REGSEL=0
   94   2          wait_us(1);
   95   2          GPIO_Port_High(ENABLE_MASK); // latch the command into the LCD panel = 1
   96   2          wait_us(1);
   97   2          GPIO_Port_Low(ENABLE_MASK); // latch the command into the LCD panel ENABLE=0
   98   2          wait_us(5000); // wait for LCD
   99   2        }
  100   1        disp_cmd(DISP_FUNC); // set the display for an 8
  101   1        wait_us(5000); // wait for LCD
  102   1        disp_cmd(DISP_CNTL | DISP_ON ); // turn the display on, cursor off
  103   1        wait_us(5000); // wait for LCD
  104   1        /*********************Added Function **************************************/
  105   1        disp_cmd(0x14);
  106   1        wait_us(5000);
  107   1        disp_cmd(DISP_CLEAR); // clear the display
  108   1        wait_us(5000); // wait for LCD
  109   1        disp_cmd(DISP_ENTRY); // set the character entry
  110   1        // mode to increment display
  111   1        // address for each
  112   1        // character, but not to scroll
  113   1        wait_us(5000);
  114   1      }
  115          void display(unsigned char arr[])
  116          {
  117   1        int i=0;
  118   1        disp_cmd(0x80);
  119   1        wait_us(5000);
  120   1        for(i=0;i<10;i++)
  121   1        {
  122   2          if(arr[i])
  123   2          {
  124   3            disp_write(arr[i]);
  125   3            wait_us(5000);
ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 3   

  126   3          }
  127   2          else
  128   2          return;
  129   2        }
  130   1      }
  131          
  132          char hex2char(unsigned char arr[])
  133          {
  134   1        int num = atoi(arr);
  135   1        num %= 100;
  136   1        num *= 100;
  137   1        switch(num)
  138   1        {
  139   2          case 0: return 'A'; break;
  140   2          case 1: return 'B'; break;
  141   2          case 2: return 'C'; break;
  142   2          case 3: return 'D'; break;
  143   2          case 4: return 'E'; break;
  144   2          case 5: return 'F'; break;
  145   2          case 6: return 'G'; break;
  146   2          case 7: return 'H'; break;
  147   2          case 8: return 'I'; break;
  148   2          case 9: return 'J'; break;
  149   2          case 10: return 'K'; break;
  150   2          case 11: return 'L'; break;
  151   2          case 12: return 'M'; break;
  152   2          case 13: return 'N'; break;
  153   2          case 14: return 'O'; break;
  154   2          case 15: return 'P'; break;
  155   2          case 16: return 'Q'; break;
  156   2          case 17: return 'R'; break;
  157   2          case 18: return 'S'; break;
  158   2          case 19: return 'T'; break;
  159   2          case 20: return 'U'; break;
  160   2          case 21: return 'V'; break;
  161   2          case 22: return 'W'; break;
  162   2          case 23: return 'X'; break;
  163   2          case 24: return 'Y'; break;
  164   2          case 25: return 'Z'; break;
  165   2          case 26: return '1'; break;
  166   2          case 27: return '2'; break;
  167   2          case 28: return '3'; break;
  168   2          case 29: return '4'; break;
  169   2          case 30: return '5'; break;
  170   2          case 31: return '6'; break;
  171   2          case 32: return '7'; break;
  172   2          default: return '#'; break;
  173   2        }
  174   1      }
  175          
  176          int main(void)
  177          {
  178   1        int i, counter = 10;
  179   1        unsigned int value; unsigned char d_hex[4];
  180   1        char vals[10];
  181   1        PINSEL0=0X00000C00;
  182   1        lcd_init();
  183   1        display(".........");
  184   1        display("SCN_START");
  185   1        Delay(LONG_DELAY*2);
  186   1        while(counter)
  187   1        {
  188   2          Delay(SHORT_DELAY);
  189   2          AD0CR=0X01200680;//select chnl 1,divide pclk by 06+1,burst controlled by software,
  190   2          //10clks 9bits,a/d on operational mode,start conversion on rising edge.
  191   2          do
ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 4   

  192   2          {
  193   3            value=AD0DR7;
  194   3          } while(value & 0x80000000 );//wait for the conversion done bit to be 1
  195   2          value=((value >>6)& 0x3ff );//
  196   2          value= (value * 3300)/0x3ff;//
  197   2          i=3;
  198   2          while(i>=0)
  199   2          {
  200   3            d_hex[i]=(value%10)+48;
  201   3            value=value/10;
  202   3            i--;
  203   3          }
  204   2          vals[counter - 1] = hex2char(& d_hex[0]);
  205   2          counter--;
  206   2          Delay(SHORT_DELAY);
  207   2        }
  208   1        display("SCN_COMPLT");
  209   1        Delay(LONG_DELAY*3);
  210   1        display(vals);
  211   1        return 0;
  212   1      }
ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 5   

ASSEMBLY LISTING OF GENERATED OBJECT CODE



*** EXTERNALS:
 EXTERN CODE16 (atoi?T)
 EXTERN CODE16 (?C?SDIV?T)
 EXTERN NUMBER (__startup)
 EXTERN CODE16 (?C?UDIV?T)



*** PUBLICS:
 PUBLIC         wait_us?T
 PUBLIC         GPIO_Port_Low?T
 PUBLIC         GPIO_Port_High?T
 PUBLIC         GPIO_Set_Port?T
 PUBLIC         disp_cmd?T
 PUBLIC         disp_write?T
 PUBLIC         lcd_init?T
 PUBLIC         Delay?T
 PUBLIC         display?T
 PUBLIC         hex2char?T
 PUBLIC         main



*** DATA SEGMENT '?CON?final':
 00000000          ??S_3:
 00000000            DB          'SCN_COMPLT',0x00
 0000000B          ??S_2:
 0000000B            DB          'SCN_START',0x00
 00000015          ??S_1:
 00000015            DB          '.........',0x00

*** DATA SEGMENT '?DT0?final':
 00000000          i:
 00000000            DS          4



*** CODE SEGMENT '?PR?Delay?T?final':
   34: void Delay(int delay)
 00000000  B410      PUSH        {R4}
 00000002  ---- Variable 'delay' assigned to Register 'R0' ----
   35: {
 00000002            ; SCOPE-START
   37:   for(i=0; i<delay; i++)
 00000002  2100      MOV         R1,#0x0
 00000004  ---- Variable 'i' assigned to Register 'R1' ----
 00000004  E006      B           L_3  ; T=0x00000014
   38:   for(j=0; j<1234; j++);
 00000006          L_10:
 00000006  2200      MOV         R2,#0x0
 00000008  ---- Variable 'j' assigned to Register 'R2' ----
 00000008          L_6:
 00000008  3201      ADD         R2,#0x1
 0000000A  1C13      MOV         R3,R2 ; j
 0000000C  4800      LDR         R4,=0x4D2
 0000000E  42A3      CMP         R3,R4 ; j
 00000010  D3FA      BCC         L_6  ; T=0x00000008
 00000012  3101      ADD         R1,#0x1
 00000014          L_3:
 00000014  1C03      MOV         R3,R0 ; delay
 00000016  1C0A      MOV         R2,R1 ; i
 00000018  429A      CMP         R2,R3 ; i
 0000001A  D3F4      BCC         L_10  ; T=0x00000006
 0000001C            ; SCOPE-END
   39: }
 0000001C  BC10      POP         {R4}
 0000001E  4770      BX          R14
 00000020          ENDP ; 'Delay?T'


*** CODE SEGMENT '?PR?wait_us?T?final':
   41: void wait_us (unsigned long usdelay )
ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 6   

 00000000  ---- Variable 'usdelay' assigned to Register 'R0' ----
   44:   usdelay=usdelay/0x10;
 00000000  0900      LSR         R0,R0,#0x4 ; usdelay
   45:   for(i=0;i<=usdelay;i++)
 00000002  2200      MOV         R2,#0x0
 00000004  4800      LDR         R1,=i ; i
 00000006  600A      STR         R2,[R1,#0x0] ; i
 00000008  E003      B           L_13  ; T=0x00000012
   48:   }
 0000000A          L_11:
 0000000A  4800      LDR         R1,=i ; i
 0000000C  680A      LDR         R2,[R1,#0x0] ; i
 0000000E  3201      ADD         R2,#0x1
 00000010  600A      STR         R2,[R1,#0x0] ; i
 00000012          L_13:
 00000012  1C02      MOV         R2,R0 ; usdelay
 00000014  4800      LDR         R1,=i ; i
 00000016  6809      LDR         R1,[R1,#0x0] ; i
 00000018  4291      CMP         R1,R2 ; usdelay
 0000001A  D9F6      BLS         L_11  ; T=0x0000000A
   49: }
 0000001C  4770      BX          R14
 0000001E          ENDP ; 'wait_us?T'


*** CODE SEGMENT '?PR?GPIO_Port_Low?T?final':
   50: void GPIO_Port_Low(unsigned int value)
 00000000  B500      PUSH        {LR}
 00000002  ---- Variable 'value' assigned to Register 'R0' ----
   52:   IO1CLR = value; // clear zeros'
 00000002  1C01      MOV         R1,R0 ; value
 00000004  4800      LDR         R0,=0xE002801C
 00000006  6001      STR         R1,[R0,#0x0]
   53:   wait_us(1); // slow down timing for LCD compatibility
 00000008  2001      MOV         R0,#0x1
 0000000A  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          wait_us?T  ; T=0x0001  (2)
   54: }
 0000000E  BC08      POP         {R3}
 00000010  4718      BX          R3
 00000012          ENDP ; 'GPIO_Port_Low?T'


*** CODE SEGMENT '?PR?GPIO_Port_High?T?final':
   55: void GPIO_Port_High(unsigned int value){
 00000000  B500      PUSH        {LR}
 00000002  ---- Variable 'value' assigned to Register 'R0' ----
   56:   IO1SET = value; // set ones'
 00000002  1C01      MOV         R1,R0 ; value
 00000004  4800      LDR         R0,=0xE0028014
 00000006  6001      STR         R1,[R0,#0x0]
   57:   wait_us(1); // slow down timing for LCD compatibility
 00000008  2001      MOV         R0,#0x1
 0000000A  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 0000000C  FFF9      BL          wait_us?T  ; T=0x0001  (2)
   58: }
 0000000E  BC08      POP         {R3}
 00000010  4718      BX          R3
 00000012          ENDP ; 'GPIO_Port_High?T'


*** CODE SEGMENT '?PR?GPIO_Set_Port?T?final':
   59: void GPIO_Set_Port(unsigned int mask, unsigned int value)
 00000000  B500      PUSH        {LR}
 00000002  1C0B      MOV         R3,R1 ; value
 00000004  ---- Variable 'value' assigned to Register 'R3' ----
 00000004  ---- Variable 'mask' assigned to Register 'R0' ----
   61:   IO1SET = mask & value; // set ones'
 00000004  1C19      MOV         R1,R3 ; value
 00000006  1C02      MOV         R2,R0 ; mask
 00000008  400A      AND         R2,R1 ; value
 0000000A  4800      LDR         R1,=0xE0028014
ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 7   

 0000000C  600A      STR         R2,[R1,#0x0]
   62:   IO1CLR = mask & (~value); // clear zeros'
 0000000E  1C1A      MOV         R2,R3 ; value
 00000010  1C01      MOV         R1,R0 ; mask
 00000012  4391      BIC         R1,R2 ; value
 00000014  4800      LDR         R0,=0xE002801C
 00000016  6001      STR         R1,[R0,#0x0]
   63:   wait_us(1); // slow down timing for LCD compatibility
 00000018  2001      MOV         R0,#0x1
 0000001A  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 0000001C  FFF1      BL          wait_us?T  ; T=0x0001  (2)
   64: }
 0000001E  BC08      POP         {R3}
 00000020  4718      BX          R3
 00000022          ENDP ; 'GPIO_Set_Port?T'


*** CODE SEGMENT '?PR?disp_cmd?T?final':
   65: void disp_cmd(unsigned char cmd)
 00000000  B500      PUSH        {LR}
 00000002  1C01      MOV         R1,R0 ; cmd
 00000004  ---- Variable 'cmd' assigned to Register 'R1' ----
   67:   IO1DIR = (IO1DIR | DISPDATA_MASK | REGSEL_MASK | ENABLE_MASK); // set ports to outputs
 00000004  4800      LDR         R0,=0xE0028018
 00000006  6802      LDR         R2,[R0,#0x0]
 00000008  4800      LDR         R0,=0x3FF0000
 0000000A  4302      ORR         R2,R0
 0000000C  4800      LDR         R0,=0xE0028018
 0000000E  6002      STR         R2,[R0,#0x0]
   68:   GPIO_Set_Port(DISPDATA_MASK, cmd<<16); // latch the command
 00000010  1C08      MOV         R0,R1 ; cmd
 00000012  0601      LSL         R1,R0,#0x18 ; cmd
 00000014  0E09      LSR         R1,R1,#0x18
 00000016  0409      LSL         R1,R1,#0x10
 00000018  4800      LDR         R0,=0xFF0000
 0000001A  F7FF      BL          GPIO_Set_Port?T  ; T=0x0001  (1)
 0000001C  FFF1      BL          GPIO_Set_Port?T  ; T=0x0001  (2)
   69:   GPIO_Port_Low(REGSEL_MASK); // select the command reg = 0
 0000001E  4800      LDR         R0,=0x2000000
 00000020  F7FF      BL          GPIO_Port_Low?T  ; T=0x0001  (1)
 00000022  FFEE      BL          GPIO_Port_Low?T  ; T=0x0001  (2)
   70:   wait_us(1);
 00000024  2001      MOV         R0,#0x1
 00000026  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000028  FFEB      BL          wait_us?T  ; T=0x0001  (2)
   71:   GPIO_Port_High(ENABLE_MASK); // latch the command into the LCD panel = 1 - first nibble
 0000002A  4800      LDR         R0,=0x1000000
 0000002C  F7FF      BL          GPIO_Port_High?T  ; T=0x0001  (1)
 0000002E  FFE8      BL          GPIO_Port_High?T  ; T=0x0001  (2)
   72:   wait_us(1);
 00000030  2001      MOV         R0,#0x1
 00000032  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000034  FFE5      BL          wait_us?T  ; T=0x0001  (2)
   73:   GPIO_Port_Low(ENABLE_MASK); // ENABLE=0;
 00000036  4800      LDR         R0,=0x1000000
 00000038  F7FF      BL          GPIO_Port_Low?T  ; T=0x0001  (1)
 0000003A  FFE2      BL          GPIO_Port_Low?T  ; T=0x0001  (2)
   74:   wait_us(1);
 0000003C  2001      MOV         R0,#0x1
 0000003E  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000040  FFDF      BL          wait_us?T  ; T=0x0001  (2)
   75: }
 00000042  BC08      POP         {R3}
 00000044  4718      BX          R3
 00000046          ENDP ; 'disp_cmd?T'


*** CODE SEGMENT '?PR?disp_write?T?final':
   76: void disp_write(unsigned char value)
 00000000  B500      PUSH        {LR}
ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 8   

 00000002  1C01      MOV         R1,R0 ; value
 00000004  ---- Variable 'value' assigned to Register 'R1' ----
   78:   IO1DIR = IO1DIR | DISPDATA_MASK | REGSEL_MASK | ENABLE_MASK; // select write mode RDWR=0
 00000004  4800      LDR         R0,=0xE0028018
 00000006  6802      LDR         R2,[R0,#0x0]
 00000008  4800      LDR         R0,=0x3FF0000
 0000000A  4302      ORR         R2,R0
 0000000C  4800      LDR         R0,=0xE0028018
 0000000E  6002      STR         R2,[R0,#0x0]
   79:   GPIO_Set_Port(DISPDATA_MASK, value<<16); // latch the data upper nibble
 00000010  1C08      MOV         R0,R1 ; value
 00000012  0601      LSL         R1,R0,#0x18 ; value
 00000014  0E09      LSR         R1,R1,#0x18
 00000016  0409      LSL         R1,R1,#0x10
 00000018  4800      LDR         R0,=0xFF0000
 0000001A  F7FF      BL          GPIO_Set_Port?T  ; T=0x0001  (1)
 0000001C  FFF1      BL          GPIO_Set_Port?T  ; T=0x0001  (2)
   80:   GPIO_Port_High(REGSEL_MASK); // select the command reg = 1 select data reg
 0000001E  4800      LDR         R0,=0x2000000
 00000020  F7FF      BL          GPIO_Port_High?T  ; T=0x0001  (1)
 00000022  FFEE      BL          GPIO_Port_High?T  ; T=0x0001  (2)
   81:   wait_us(1);
 00000024  2001      MOV         R0,#0x1
 00000026  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000028  FFEB      BL          wait_us?T  ; T=0x0001  (2)
   82:   GPIO_Port_High(ENABLE_MASK); // latch the command into the LCD panel = 1
 0000002A  4800      LDR         R0,=0x1000000
 0000002C  F7FF      BL          GPIO_Port_High?T  ; T=0x0001  (1)
 0000002E  FFE8      BL          GPIO_Port_High?T  ; T=0x0001  (2)
   83:   wait_us(1);
 00000030  2001      MOV         R0,#0x1
 00000032  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000034  FFE5      BL          wait_us?T  ; T=0x0001  (2)
   84:   GPIO_Port_Low(ENABLE_MASK); // ENABLE=0;
 00000036  4800      LDR         R0,=0x1000000
 00000038  F7FF      BL          GPIO_Port_Low?T  ; T=0x0001  (1)
 0000003A  FFE2      BL          GPIO_Port_Low?T  ; T=0x0001  (2)
   85:   wait_us(1);
 0000003C  2001      MOV         R0,#0x1
 0000003E  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000040  FFDF      BL          wait_us?T  ; T=0x0001  (2)
   86: }
 00000042  BC08      POP         {R3}
 00000044  4718      BX          R3
 00000046          ENDP ; 'disp_write?T'


*** CODE SEGMENT '?PR?lcd_init?T?final':
   87: void lcd_init(void) {
 00000000  B510      PUSH        {R4,LR}
 00000002            ; SCOPE-START
   89:   IO1DIR = IO1DIR | DISPDATA_MASK | REGSEL_MASK |ENABLE_MASK;  // select port direction=output
 00000002  4800      LDR         R0,=0xE0028018
 00000004  6801      LDR         R1,[R0,#0x0]
 00000006  4800      LDR         R0,=0x3FF0000
 00000008  4301      ORR         R1,R0
 0000000A  4800      LDR         R0,=0xE0028018
 0000000C  6001      STR         R1,[R0,#0x0]
   90:   wait_us(20000); // wait for LCD to reset itself
 0000000E  4800      LDR         R0,=0x4E20
 00000010  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000012  FFF6      BL          wait_us?T  ; T=0x0001  (2)
   91:   for(counter = 0; counter <3; counter++){
 00000014  2400      MOV         R4,#0x0
 00000016  ---- Variable 'counter' assigned to Register 'R4' ----
 00000016  E018      B           L_18  ; T=0x0000004A
 00000018          L_19:
   92:     GPIO_Set_Port(DISPDATA_MASK, (0x00020000)); // latch the command 0x30
ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 9   

 00000018  4800      LDR         R0,=0xFF0000
 0000001A  4800      LDR         R1,=0x20000
 0000001C  F7FF      BL          GPIO_Set_Port?T  ; T=0x0001  (1)
 0000001E  FFF0      BL          GPIO_Set_Port?T  ; T=0x0001  (2)
   93:     GPIO_Port_Low(REGSEL_MASK); // select the command reg REGSEL=0
 00000020  4800      LDR         R0,=0x2000000
 00000022  F7FF      BL          GPIO_Port_Low?T  ; T=0x0001  (1)
 00000024  FFED      BL          GPIO_Port_Low?T  ; T=0x0001  (2)
   94:     wait_us(1);
 00000026  2001      MOV         R0,#0x1
 00000028  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 0000002A  FFEA      BL          wait_us?T  ; T=0x0001  (2)
   95:     GPIO_Port_High(ENABLE_MASK); // latch the command into the LCD panel = 1
 0000002C  4800      LDR         R0,=0x1000000
 0000002E  F7FF      BL          GPIO_Port_High?T  ; T=0x0001  (1)
 00000030  FFE7      BL          GPIO_Port_High?T  ; T=0x0001  (2)
   96:     wait_us(1);
 00000032  2001      MOV         R0,#0x1
 00000034  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000036  FFE4      BL          wait_us?T  ; T=0x0001  (2)
   97:     GPIO_Port_Low(ENABLE_MASK); // latch the command into the LCD panel ENABLE=0
 00000038  4800      LDR         R0,=0x1000000
 0000003A  F7FF      BL          GPIO_Port_Low?T  ; T=0x0001  (1)
 0000003C  FFE1      BL          GPIO_Port_Low?T  ; T=0x0001  (2)
   98:     wait_us(5000); // wait for LCD
 0000003E  4800      LDR         R0,=0x1388
 00000040  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000042  FFDE      BL          wait_us?T  ; T=0x0001  (2)
   99:   }
 00000044  3401      ADD         R4,#0x1
 00000046  0624      LSL         R4,R4,#0x18
 00000048  0E24      LSR         R4,R4,#0x18
 0000004A          L_18:
 0000004A  1C20      MOV         R0,R4 ; counter
 0000004C  0600      LSL         R0,R0,#0x18 ; counter
 0000004E  0E00      LSR         R0,R0,#0x18
 00000050  2803      CMP         R0,#0x3
 00000052  DBE1      BLT         L_19  ; T=0x00000018
  100:   disp_cmd(DISP_FUNC); // set the display for an 8
 00000054  2038      MOV         R0,#0x38
 00000056  F7FF      BL          disp_cmd?T  ; T=0x0001  (1)
 00000058  FFD3      BL          disp_cmd?T  ; T=0x0001  (2)
  101:   wait_us(5000); // wait for LCD
 0000005A  4800      LDR         R0,=0x1388
 0000005C  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 0000005E  FFD0      BL          wait_us?T  ; T=0x0001  (2)
  102:   disp_cmd(DISP_CNTL | DISP_ON ); // turn the display on, cursor off
 00000060  200C      MOV         R0,#0xC
 00000062  F7FF      BL          disp_cmd?T  ; T=0x0001  (1)
 00000064  FFCD      BL          disp_cmd?T  ; T=0x0001  (2)
  103:   wait_us(5000); // wait for LCD
 00000066  4800      LDR         R0,=0x1388
 00000068  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 0000006A  FFCA      BL          wait_us?T  ; T=0x0001  (2)
  105:   disp_cmd(0x14);
 0000006C  2014      MOV         R0,#0x14
 0000006E  F7FF      BL          disp_cmd?T  ; T=0x0001  (1)
 00000070  FFC7      BL          disp_cmd?T  ; T=0x0001  (2)
  106:   wait_us(5000);
 00000072  4800      LDR         R0,=0x1388
 00000074  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000076  FFC4      BL          wait_us?T  ; T=0x0001  (2)
  107:   disp_cmd(DISP_CLEAR); // clear the display
 00000078  2001      MOV         R0,#0x1
 0000007A  F7FF      BL          disp_cmd?T  ; T=0x0001  (1)
 0000007C  FFC1      BL          disp_cmd?T  ; T=0x0001  (2)
ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 10  

  108:   wait_us(5000); // wait for LCD
 0000007E  4800      LDR         R0,=0x1388
 00000080  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000082  FFBE      BL          wait_us?T  ; T=0x0001  (2)
  109:   disp_cmd(DISP_ENTRY); // set the character entry
 00000084  2006      MOV         R0,#0x6
 00000086  F7FF      BL          disp_cmd?T  ; T=0x0001  (1)
 00000088  FFBB      BL          disp_cmd?T  ; T=0x0001  (2)
  113:   wait_us(5000);
 0000008A  4800      LDR         R0,=0x1388
 0000008C  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 0000008E  FFB8      BL          wait_us?T  ; T=0x0001  (2)
 00000090            ; SCOPE-END
  114: }
 00000090  BC10      POP         {R4}
 00000092  BC08      POP         {R3}
 00000094  4718      BX          R3
 00000096          ENDP ; 'lcd_init?T'


*** CODE SEGMENT '?PR?display?T?final':
  115: void display(unsigned char arr[])
 00000000  B530      PUSH        {R4-R5,LR}
 00000002  1C05      MOV         R5,R0 ; arr
 00000004  ---- Variable 'arr' assigned to Register 'R5' ----
  116: {
 00000004            ; SCOPE-START
  117:   int i=0;
 00000004  2400      MOV         R4,#0x0
 00000006  ---- Variable 'i' assigned to Register 'R4' ----
  118:   disp_cmd(0x80);
 00000006  2080      MOV         R0,#0x80
 00000008  F7FF      BL          disp_cmd?T  ; T=0x0001  (1)
 0000000A  FFFA      BL          disp_cmd?T  ; T=0x0001  (2)
  119:   wait_us(5000);
 0000000C  4800      LDR         R0,=0x1388
 0000000E  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000010  FFF7      BL          wait_us?T  ; T=0x0001  (2)
  120:   for(i=0;i<10;i++)
 00000012  2400      MOV         R4,#0x0
 00000014          L_24:
  122:     if(arr[i])
 00000014  1C21      MOV         R1,R4 ; i
 00000016  1C28      MOV         R0,R5 ; arr
 00000018  5C40      LDRB        R0,[R0,R1]
 0000001A  2800      CMP         R0,#0x0
 0000001C  D008      BEQ         L_28  ; T=0x00000030
  124:       disp_write(arr[i]);
 0000001E  F7FF      BL          disp_write?T  ; T=0x0001  (1)
 00000020  FFEF      BL          disp_write?T  ; T=0x0001  (2)
  125:       wait_us(5000);
 00000022  4800      LDR         R0,=0x1388
 00000024  F7FF      BL          wait_us?T  ; T=0x0001  (1)
 00000026  FFEC      BL          wait_us?T  ; T=0x0001  (2)
  129:   }
 00000028  3401      ADD         R4,#0x1
 0000002A  1C20      MOV         R0,R4 ; i
 0000002C  280A      CMP         R0,#0xA ; i
 0000002E  DBF1      BLT         L_24  ; T=0x00000014
 00000030            ; SCOPE-END
  130: }
 00000030          L_28:
 00000030  BC30      POP         {R4-R5}
 00000032  BC08      POP         {R3}
 00000034  4718      BX          R3
 00000036          ENDP ; 'display?T'


*** CODE SEGMENT '?PR?hex2char?T?final':
  132: char hex2char(unsigned char arr[])
ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 11  

 00000000  B500      PUSH        {LR}
 00000002  1C01      MOV         R1,R0 ; arr
 00000004  ---- Variable 'arr' assigned to Register 'R1' ----
  133: {
 00000004            ; SCOPE-START
  134:   int num = atoi(arr);
 00000004  1C08      MOV         R0,R1 ; arr
 00000006  F7FF      BL          atoi?T  ; T=0x0001  (1)
 00000008  FFFB      BL          atoi?T  ; T=0x0001  (2)
 0000000A  1C02      MOV         R2,R0 ; num
 0000000C  ---- Variable 'num' assigned to Register 'R2' ----
  135:   num %= 100;
 0000000C  1C10      MOV         R0,R2 ; num
 0000000E  2364      MOV         R3,#0x64
 00000010  1C19      MOV         R1,R3
 00000012  F7FF      BL          ?C?SDIV?T  ; T=0x0001  (1) ; ?C?SDIV?T
 00000014  FFF5      BL          ?C?SDIV?T  ; T=0x0001  (2) ; ?C?SDIV?T
 00000016  1C01      MOV         R1,R0
 00000018  1C0A      MOV         R2,R1 ; num
  136:   num *= 100;
 0000001A  435A      MUL         R2,R3
  137:   switch(num)
 0000001C  1C10      MOV         R0,R2 ; num
 0000001E  2801      CMP         R0,#0x1 ; num
 00000020  D041      BEQ         L_32  ; T=0x000000A6
 00000022  2802      CMP         R0,#0x2 ; num
 00000024  D041      BEQ         L_33  ; T=0x000000AA
 00000026  2803      CMP         R0,#0x3 ; num
 00000028  D041      BEQ         L_34  ; T=0x000000AE
 0000002A  2804      CMP         R0,#0x4 ; num
 0000002C  D041      BEQ         L_35  ; T=0x000000B2
 0000002E  2805      CMP         R0,#0x5 ; num
 00000030  D041      BEQ         L_36  ; T=0x000000B6
 00000032  2806      CMP         R0,#0x6 ; num
 00000034  D041      BEQ         L_37  ; T=0x000000BA
 00000036  2807      CMP         R0,#0x7 ; num
 00000038  D041      BEQ         L_38  ; T=0x000000BE
 0000003A  2808      CMP         R0,#0x8 ; num
 0000003C  D041      BEQ         L_39  ; T=0x000000C2
 0000003E  2809      CMP         R0,#0x9 ; num
 00000040  D041      BEQ         L_40  ; T=0x000000C6
 00000042  280A      CMP         R0,#0xA ; num
 00000044  D041      BEQ         L_41  ; T=0x000000CA
 00000046  280B      CMP         R0,#0xB ; num
 00000048  D041      BEQ         L_42  ; T=0x000000CE
 0000004A  280C      CMP         R0,#0xC ; num
 0000004C  D041      BEQ         L_43  ; T=0x000000D2
 0000004E  280D      CMP         R0,#0xD ; num
 00000050  D041      BEQ         L_44  ; T=0x000000D6
 00000052  280E      CMP         R0,#0xE ; num
 00000054  D041      BEQ         L_45  ; T=0x000000DA
 00000056  280F      CMP         R0,#0xF ; num
 00000058  D041      BEQ         L_46  ; T=0x000000DE
 0000005A  2810      CMP         R0,#0x10 ; num
 0000005C  D041      BEQ         L_47  ; T=0x000000E2
 0000005E  2811      CMP         R0,#0x11 ; num
 00000060  D041      BEQ         L_48  ; T=0x000000E6
 00000062  2812      CMP         R0,#0x12 ; num
 00000064  D041      BEQ         L_49  ; T=0x000000EA
 00000066  2813      CMP         R0,#0x13 ; num
 00000068  D041      BEQ         L_50  ; T=0x000000EE
 0000006A  2814      CMP         R0,#0x14 ; num
 0000006C  D041      BEQ         L_51  ; T=0x000000F2
 0000006E  2815      CMP         R0,#0x15 ; num
 00000070  D041      BEQ         L_52  ; T=0x000000F6
 00000072  2816      CMP         R0,#0x16 ; num
ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 12  

 00000074  D041      BEQ         L_53  ; T=0x000000FA
 00000076  2817      CMP         R0,#0x17 ; num
 00000078  D041      BEQ         L_54  ; T=0x000000FE
 0000007A  2818      CMP         R0,#0x18 ; num
 0000007C  D041      BEQ         L_55  ; T=0x00000102
 0000007E  2819      CMP         R0,#0x19 ; num
 00000080  D041      BEQ         L_56  ; T=0x00000106
 00000082  281A      CMP         R0,#0x1A ; num
 00000084  D041      BEQ         L_57  ; T=0x0000010A
 00000086  281B      CMP         R0,#0x1B ; num
 00000088  D041      BEQ         L_58  ; T=0x0000010E
 0000008A  281C      CMP         R0,#0x1C ; num
 0000008C  D041      BEQ         L_59  ; T=0x00000112
 0000008E  281D      CMP         R0,#0x1D ; num
 00000090  D041      BEQ         L_60  ; T=0x00000116
 00000092  281E      CMP         R0,#0x1E ; num
 00000094  D041      BEQ         L_61  ; T=0x0000011A
 00000096  281F      CMP         R0,#0x1F ; num
 00000098  D041      BEQ         L_62  ; T=0x0000011E
 0000009A  2820      CMP         R0,#0x20 ; num
 0000009C  D041      BEQ         L_63  ; T=0x00000122
 0000009E  2800      CMP         R0,#0x0 ; num
 000000A0  D141      BNE         L_31  ; T=0x00000126
  139:     case 0: return 'A'; break;
 000000A2          L_30:
 000000A2  2041      MOV         R0,#0x41
 000000A4  E040      B           L_64  ; T=0x00000128
  140:     case 1: return 'B'; break;
 000000A6          L_32:
 000000A6  2042      MOV         R0,#0x42
 000000A8  E03E      B           L_64  ; T=0x00000128
  141:     case 2: return 'C'; break;
 000000AA          L_33:
 000000AA  2043      MOV         R0,#0x43
 000000AC  E03C      B           L_64  ; T=0x00000128
  142:     case 3: return 'D'; break;
 000000AE          L_34:
 000000AE  2044      MOV         R0,#0x44
 000000B0  E03A      B           L_64  ; T=0x00000128
  143:     case 4: return 'E'; break;
 000000B2          L_35:
 000000B2  2045      MOV         R0,#0x45
 000000B4  E038      B           L_64  ; T=0x00000128
  144:     case 5: return 'F'; break;
 000000B6          L_36:
 000000B6  2046      MOV         R0,#0x46
 000000B8  E036      B           L_64  ; T=0x00000128
  145:     case 6: return 'G'; break;
 000000BA          L_37:
 000000BA  2047      MOV         R0,#0x47
 000000BC  E034      B           L_64  ; T=0x00000128
  146:     case 7: return 'H'; break;
 000000BE          L_38:
 000000BE  2048      MOV         R0,#0x48
 000000C0  E032      B           L_64  ; T=0x00000128
  147:     case 8: return 'I'; break;
 000000C2          L_39:
 000000C2  2049      MOV         R0,#0x49
 000000C4  E030      B           L_64  ; T=0x00000128
  148:     case 9: return 'J'; break;
 000000C6          L_40:
 000000C6  204A      MOV         R0,#0x4A
 000000C8  E02E      B           L_64  ; T=0x00000128
  149:     case 10: return 'K'; break;
 000000CA          L_41:
 000000CA  204B      MOV         R0,#0x4B
ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 13  

 000000CC  E02C      B           L_64  ; T=0x00000128
  150:     case 11: return 'L'; break;
 000000CE          L_42:
 000000CE  204C      MOV         R0,#0x4C
 000000D0  E02A      B           L_64  ; T=0x00000128
  151:     case 12: return 'M'; break;
 000000D2          L_43:
 000000D2  204D      MOV         R0,#0x4D
 000000D4  E028      B           L_64  ; T=0x00000128
  152:     case 13: return 'N'; break;
 000000D6          L_44:
 000000D6  204E      MOV         R0,#0x4E
 000000D8  E026      B           L_64  ; T=0x00000128
  153:     case 14: return 'O'; break;
 000000DA          L_45:
 000000DA  204F      MOV         R0,#0x4F
 000000DC  E024      B           L_64  ; T=0x00000128
  154:     case 15: return 'P'; break;
 000000DE          L_46:
 000000DE  2050      MOV         R0,#0x50
 000000E0  E022      B           L_64  ; T=0x00000128
  155:     case 16: return 'Q'; break;
 000000E2          L_47:
 000000E2  2051      MOV         R0,#0x51
 000000E4  E020      B           L_64  ; T=0x00000128
  156:     case 17: return 'R'; break;
 000000E6          L_48:
 000000E6  2052      MOV         R0,#0x52
 000000E8  E01E      B           L_64  ; T=0x00000128
  157:     case 18: return 'S'; break;
 000000EA          L_49:
 000000EA  2053      MOV         R0,#0x53
 000000EC  E01C      B           L_64  ; T=0x00000128
  158:     case 19: return 'T'; break;
 000000EE          L_50:
 000000EE  2054      MOV         R0,#0x54
 000000F0  E01A      B           L_64  ; T=0x00000128
  159:     case 20: return 'U'; break;
 000000F2          L_51:
 000000F2  2055      MOV         R0,#0x55
 000000F4  E018      B           L_64  ; T=0x00000128
  160:     case 21: return 'V'; break;
 000000F6          L_52:
 000000F6  2056      MOV         R0,#0x56
 000000F8  E016      B           L_64  ; T=0x00000128
  161:     case 22: return 'W'; break;
 000000FA          L_53:
 000000FA  2057      MOV         R0,#0x57
 000000FC  E014      B           L_64  ; T=0x00000128
  162:     case 23: return 'X'; break;
 000000FE          L_54:
 000000FE  2058      MOV         R0,#0x58
 00000100  E012      B           L_64  ; T=0x00000128
  163:     case 24: return 'Y'; break;
 00000102          L_55:
 00000102  2059      MOV         R0,#0x59
 00000104  E010      B           L_64  ; T=0x00000128
  164:     case 25: return 'Z'; break;
 00000106          L_56:
 00000106  205A      MOV         R0,#0x5A
 00000108  E00E      B           L_64  ; T=0x00000128
  165:     case 26: return '1'; break;
 0000010A          L_57:
 0000010A  2031      MOV         R0,#0x31
 0000010C  E00C      B           L_64  ; T=0x00000128
  166:     case 27: return '2'; break;
ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 14  

 0000010E          L_58:
 0000010E  2032      MOV         R0,#0x32
 00000110  E00A      B           L_64  ; T=0x00000128
  167:     case 28: return '3'; break;
 00000112          L_59:
 00000112  2033      MOV         R0,#0x33
 00000114  E008      B           L_64  ; T=0x00000128
  168:     case 29: return '4'; break;
 00000116          L_60:
 00000116  2034      MOV         R0,#0x34
 00000118  E006      B           L_64  ; T=0x00000128
  169:     case 30: return '5'; break;
 0000011A          L_61:
 0000011A  2035      MOV         R0,#0x35
 0000011C  E004      B           L_64  ; T=0x00000128
  170:     case 31: return '6'; break;
 0000011E          L_62:
 0000011E  2036      MOV         R0,#0x36
 00000120  E002      B           L_64  ; T=0x00000128
  171:     case 32: return '7'; break;
 00000122          L_63:
 00000122  2037      MOV         R0,#0x37
 00000124  E000      B           L_64  ; T=0x00000128
  172:     default: return '#'; break;
 00000126          L_31:
 00000126  2023      MOV         R0,#0x23
  173:   }
 00000128            ; SCOPE-END
  174: }
 00000128          L_64:
 00000128  BC08      POP         {R3}
 0000012A  4718      BX          R3
 0000012C          ENDP ; 'hex2char?T'


*** CODE SEGMENT '?PR?main?final':
  176: int main(void)
 00000000  B500      PUSH        {LR}
 00000002  B084      SUB         R13,#0x10
  177: {
 00000004            ; SCOPE-START
  178:   int i, counter = 10;
 00000004  240A      MOV         R4,#0xA
 00000006  ---- Variable 'counter' assigned to Register 'R4' ----
  181:   PINSEL0=0X00000C00;
 00000006  4800      LDR         R1,=0xC00
 00000008  4800      LDR         R0,=0xE002C000
 0000000A  6001      STR         R1,[R0,#0x0]
  182:   lcd_init();
 0000000C  F7FF      BL          lcd_init?T  ; T=0x0001  (1)
 0000000E  FFF8      BL          lcd_init?T  ; T=0x0001  (2)
  183:   display(".........");
 00000010  4800      LDR         R0,=??S_1 ; ??S_1
 00000012  F7FF      BL          display?T  ; T=0x0001  (1)
 00000014  FFF5      BL          display?T  ; T=0x0001  (2)
  184:   display("SCN_START");
 00000016  4800      LDR         R0,=??S_2 ; ??S_2
 00000018  F7FF      BL          display?T  ; T=0x0001  (1)
 0000001A  FFF2      BL          display?T  ; T=0x0001  (2)
  185:   Delay(LONG_DELAY*2);
 0000001C  4800      LDR         R0,=0xFA0
 0000001E  F7FF      BL          Delay?T  ; T=0x0001  (1)
 00000020  FFEF      BL          Delay?T  ; T=0x0001  (2)
  186:   while(counter)
 00000022          L_67:
  188:     Delay(SHORT_DELAY);
 00000022  4864      LDR         R0,=0x190
 00000024  F7FF      BL          Delay?T  ; T=0x0001  (1)
ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 15  

 00000026  FFEC      BL          Delay?T  ; T=0x0001  (2)
  189:     AD0CR=0X01200680;//select chnl 1,divide pclk by 06+1,burst controlled by software,
 00000028  4800      LDR         R1,=0x1200680
 0000002A  4800      LDR         R0,=0xE0034000
 0000002C  6001      STR         R1,[R0,#0x0]
  191:     do
 0000002E          L_69:
  193:       value=AD0DR7;
 0000002E  4800      LDR         R0,=0xE003402C
 00000030  6806      LDR         R6,[R0,#0x0]
 00000032  ---- Variable 'value' assigned to Register 'R6' ----
  194:     } while(value & 0x80000000 );//wait for the conversion done bit to be 1
 00000032  1C30      MOV         R0,R6 ; value
 00000034  4800      LDR         R1,=0x80000000
 00000036  4208      TST         R0,R1 ; value
 00000038  D1F9      BNE         L_69  ; T=0x0000002E
  195:     value=((value >>6)& 0x3ff );//
 0000003A  09B6      LSR         R6,R6,#0x6 ; value
 0000003C  4800      LDR         R1,=0x3FF
 0000003E  400E      AND         R6,R1
  196:     value= (value * 3300)/0x3ff;//
 00000040  1C30      MOV         R0,R6 ; value
 00000042  4800      LDR         R2,=0xCE4
 00000044  4350      MUL         R0,R2
 00000046  F7FF      BL          ?C?UDIV?T  ; T=0x0001  (1) ; ?C?UDIV?T
 00000048  FFDB      BL          ?C?UDIV?T  ; T=0x0001  (2) ; ?C?UDIV?T
 0000004A  1C08      MOV         R0,R1
 0000004C  1C06      MOV         R6,R0 ; value
  197:     i=3;
 0000004E  2503      MOV         R5,#0x3
 00000050  ---- Variable 'i' assigned to Register 'R5' ----
  198:     while(i>=0)
 00000050          L_75:
  200:       d_hex[i]=(value%10)+48;
 00000050  1C30      MOV         R0,R6 ; value
 00000052  210A      MOV         R1,#0xA
 00000054  F7FF      BL          ?C?UDIV?T  ; T=0x0001  (1) ; ?C?UDIV?T
 00000056  FFD4      BL          ?C?UDIV?T  ; T=0x0001  (2) ; ?C?UDIV?T
 00000058  1C01      MOV         R1,R0
 0000005A  3030      ADD         R0,#0x30
 0000005C  0600      LSL         R0,R0,#0x18
 0000005E  0E00      LSR         R0,R0,#0x18
 00000060  1C2A      MOV         R2,R5 ; i
 00000062  A900      ADD         R1,R13,#0x0
 00000064  5488      STRB        R0,[R1,R2]
  201:       value=value/10;
 00000066  1C30      MOV         R0,R6 ; value
 00000068  210A      MOV         R1,#0xA
 0000006A  F7FF      BL          ?C?UDIV?T  ; T=0x0001  (1) ; ?C?UDIV?T
 0000006C  FFC9      BL          ?C?UDIV?T  ; T=0x0001  (2) ; ?C?UDIV?T
 0000006E  1C08      MOV         R0,R1
 00000070  1C06      MOV         R6,R0 ; value
  202:       i--;
 00000072  3D01      SUB         R5,#0x1
  203:     }
 00000074  1C28      MOV         R0,R5 ; i
 00000076  2800      CMP         R0,#0x0 ; i
 00000078  DAEA      BGE         L_75  ; T=0x00000050
  204:     vals[counter - 1] = hex2char(& d_hex[0]);
 0000007A  A800      ADD         R0,R13,#0x0
 0000007C  F7FF      BL          hex2char?T  ; T=0x0001  (1)
 0000007E  FFC0      BL          hex2char?T  ; T=0x0001  (2)
 00000080  1C22      MOV         R2,R4 ; counter
 00000082  2103      MOV         R1,#0x3
 00000084  4469      ADD         R1,R13
 00000086  5488      STRB        R0,[R1,R2]
ARM COMPILER V2.41,  final                                                                 02/05/16  17:37:00  PAGE 16  

  205:     counter--;
 00000088  3C01      SUB         R4,#0x1
  206:     Delay(SHORT_DELAY);
 0000008A  4864      LDR         R0,=0x190
 0000008C  F7FF      BL          Delay?T  ; T=0x0001  (1)
 0000008E  FFB8      BL          Delay?T  ; T=0x0001  (2)
  207:   }
 00000090  1C20      MOV         R0,R4 ; counter
 00000092  2800      CMP         R0,#0x0 ; counter
 00000094  D1C5      BNE         L_67  ; T=0x00000022
  208:   display("SCN_COMPLT");
 00000096  4800      LDR         R0,=??S_3 ; ??S_3
 00000098  F7FF      BL          display?T  ; T=0x0001  (1)
 0000009A  FFB2      BL          display?T  ; T=0x0001  (2)
  209:   Delay(LONG_DELAY*3);
 0000009C  4800      LDR         R0,=0x1770
 0000009E  F7FF      BL          Delay?T  ; T=0x0001  (1)
 000000A0  FFAF      BL          Delay?T  ; T=0x0001  (2)
  210:   display(vals);
 000000A2  A801      ADD         R0,R13,#0x4
 000000A4  F7FF      BL          display?T  ; T=0x0001  (1)
 000000A6  FFAC      BL          display?T  ; T=0x0001  (2)
  211:   return 0;
 000000A8  2000      MOV         R0,#0x0
 000000AA            ; SCOPE-END
  212: }
 000000AA  B004      ADD         R13,#0x10
 000000AC  BC08      POP         {R3}
 000000AE  4718      BX          R3
 000000B0          ENDP ; 'main'



Module Information          Static
----------------------------------
  code size            =    ------
  data size            =         4
  const size           =        31
End of Module Information.


ARM COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
